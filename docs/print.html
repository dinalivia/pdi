<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Digital Image Processing - Dina Lívia</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">var path_to_root = "";</script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><a href="unit1/list.html"><strong aria-hidden="true">2.</strong> Unit 1</a></li><li><ol class="section"><li><a href="unit1/negative.html"><strong aria-hidden="true">2.1.</strong> Negative of a region</a></li><li><a href="unit1/swap_regions.html"><strong aria-hidden="true">2.2.</strong> Swapping regions</a></li><li><a href="unit1/bolhas.html"><strong aria-hidden="true">2.3.</strong> Labeling objects - Bubbles with holes</a></li><li><a href="unit1/equalization.html"><strong aria-hidden="true">2.4.</strong> Histogram equalization</a></li><li><a href="unit1/motiondetector.html"><strong aria-hidden="true">2.5.</strong> Motion Detector</a></li><li><a href="unit1/lapl_gauss.html"><strong aria-hidden="true">2.6.</strong> Laplacian of a Gaussian filter</a></li><li><a href="unit1/tiltyshift.html"><strong aria-hidden="true">2.7.</strong> Tilty Shift</a></li></ol></li><li><a href="unit2/list.html"><strong aria-hidden="true">3.</strong> Unit 2</a></li><li><ol class="section"><li><a href="unit2/homomorphic.html"><strong aria-hidden="true">3.1.</strong> Homomorphic Filter</a></li><li><a href="unit2/pointillism.html"><strong aria-hidden="true">3.2.</strong> Pointillism art</a></li><li><a href="unit2/k-means.html"><strong aria-hidden="true">3.3.</strong> The K-means process</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Digital Image Processing - Dina Lívia</h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="#introduction" id="introduction"><h1>Introduction</h1></a>
<a class="header" href="#digital-image-processing" id="digital-image-processing"><h2>Digital Image Processing</h2></a>
<p>This page contains codes and exercises that were developed for the Digital Image Processing course (2018.2) at the Universidade Federal do Rio Grande do Norte (UFRN - Brazil).</p>
<a class="header" href="#unit-1" id="unit-1"><h1>Unit 1</h1></a>
<p>In this unit, the following examples were developed:</p>
<ul>
<li>Negative of a region</li>
<li>Swapping regions</li>
<li>Counting bubbles with holes</li>
<li>Histogram equalization</li>
<li>Motion detection</li>
<li>Laplacian of Gaussian</li>
<li>Tilty Shift</li>
</ul>
<a class="header" href="#exercise-1---negative-of-a-region" id="exercise-1---negative-of-a-region"><h1>Exercise 1 - Negative of a region</h1></a>
<p>This is the first exercise using OpenCV image manipulation. In this example, we'll be reading and processing a region of a given image in order to create a negative effect on it. To achive this goal, the following fomula is used to invert the color of the pixels: <code>pixel_color = 255 - pixel_color</code>.</p>
<p>As the image used is in grayscale, we will be aplying it for one channel only. The region is seleted by a couple of for-loops that go through an area within the image, inverting its pixels, as shown below.</p>
<p><img src="../img/camera__.jpg" alt="Negative Region" title="Negative region" />
<img src="../img/negative.jpg" alt="Negative Region" title="Negative region" /></p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;opencv2/opencv.hpp&gt;

using namespace cv;
using namespace std;

int main()
{
  Mat image;
  int pxl;

  image= imread(&quot;img/camera__.jpg&quot;,CV_LOAD_IMAGE_GRAYSCALE);
  if(!image.data)
    cout &lt;&lt; &quot;couldn't load image&quot; &lt;&lt; endl;

  namedWindow(&quot;window&quot;,WINDOW_AUTOSIZE);

  for(int i=100;i&lt;200;i++){
    for(int j=100;j&lt;200;j++){
      pxl = image.at&lt;uchar&gt;(i,j);
      image.at&lt;uchar&gt;(i,j) = 255 - pxl;
    }
  }
  imwrite(&quot;negative.jpg&quot;, image);
  imshow(&quot;window&quot;, image); 

  waitKey();

  return 0;
}   
</code></pre>
<a class="header" href="#exercise-2---swapping-regions" id="exercise-2---swapping-regions"><h1>Exercise 2 - Swapping regions</h1></a>
<p>In this example, we'll create an image by swapping regions from an original one. For this, Regions of Interest (ROI) were created using rectangles with half the height and width of the original image. In sequence, using the <code>Mat (const Mat &amp;m, const Rect &amp;roi)</code> constructor, 4 images were created by using those rectangles and finally the <code>CV::Mat::copyTo(OutPutArray m)</code> method was used to perfom the swap of the 1-3 and 2-4 regions.</p>
<p><img src="../img/camera__.jpg" alt="Swapping Regions" title="Swapping regions" />
<img src="../img/swapping.jpg" alt="Swapping Regions" title="Swapping regions" /></p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;opencv2/opencv.hpp&gt;

using namespace cv;
using namespace std;

int main()
{
  Mat image = imread(&quot;img/camera__.jpg&quot;,CV_LOAD_IMAGE_GRAYSCALE);

  if(!image.data)
    cout &lt;&lt; &quot;nao abriu camera__.jpg&quot; &lt;&lt; endl;

  namedWindow(&quot;janela&quot;,WINDOW_AUTOSIZE);

  imshow(&quot;janela&quot;, image);      
  waitKey();

  int x = 0, y = 0, width = image.rows/2, height = image.cols/2;
  Mat image2; 
  image.copyTo(image2);

 // creating Regions of Interest
  Rect rois[4] = { 
        Rect(     0,      0, width, height),
        Rect(width,      0, width, height),
        Rect(     0, height, width, height),
        Rect(width, height, width, height)
        };

  // copying regions and swapping them   
  Mat region1 (image, rois[3]);
  region1.copyTo(image2(rois[0]));

  Mat region2 (image, rois[2]);
  region2.copyTo(image2(rois[1]));

  Mat region3 (image, rois[1]);
  region3.copyTo(image2(rois[2]));

  Mat region4 (image, rois[0]);
  region4.copyTo(image2(rois[3]));

  imwrite(&quot;swapping.jpg&quot;, image2);
  imshow(&quot;janela&quot;, image2);  
  waitKey();

  return 0;
}   
</code></pre>
<a class="header" href="#exercise-3-labeling-objects" id="exercise-3-labeling-objects"><h1>Exercise 3. Labeling objects</h1></a>
<a class="header" href="#example-bubbles-with-holes" id="example-bubbles-with-holes"><h3>Example: Bubbles with holes</h3></a>
<p>In this example, we'll introduce the labeling concept, a method which allow us to identify objects or regions in an image. To create labels, we made use of the <code>floodfill</code> OpenCV method, which consists of painting an area that has the same color, replacing it by another color (label). Here this technique is used for labeling and counting white bubbles in a black background,identifing and counting as well, bubbles with holes.</p>
<p>This example was based on the <a href="https://agostinhobritojr.github.io/tutorial/pdi/exemplos/labeling.cpp">labeling.cpp</a> algorithm and answers to the proposed exercises at <a href="https://agostinhobritojr.github.io/tutorial/pdi/#_descri%C3%A7%C3%A3o_do_programa_labeling_cpp">agostinhobritojr.github.io</a>.</p>
<p>The labeling.cpp algorithm works very well in cases where the amount of objects are below 255 units. But, if we have more than 255 objects to label, varying from the pixel grayscale intesity, we'll find an issue. For theses cases, another approach could be used, for instance, a diferent number representation as such as floating point can be used, so a much greater amount of objects could be labeled.</p>
<p><img src="../img/bolhas.png" alt="labeling" title="Labeling" />
<img src="../img/labeling_part1.png" alt="labeling" title="Labeling" />
<img src="../img/labeling_part2.png" alt="labeling" title="Labeling" />
<img src="../img/labeling.png" alt="labeling" title="Labeling" /></p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;opencv2/opencv.hpp&gt;

using namespace cv;

int main(){
  Mat image, mask;
  int width, height;
  int nobjects, holes, counter;

  // - Reading image --  
  CvPoint p;
  image = imread(&quot;img/bolhas.png&quot;,CV_LOAD_IMAGE_GRAYSCALE);
  
  if(!image.data){
    std::cout &lt;&lt; &quot;Couldn't load the file correctly\n&quot;;
    return(-1);
  }

  width=image.size().width;
  height=image.size().height;

  p.x = 0;
  p.y = 0;

  //  -- Excluding objects that touch the first and last lines --
  for(int i=0; i&lt;height; i++){
    if(image.at&lt;uchar&gt;(0, i) == 255){ 
        floodFill(image,Point(i, 0), 0); 
    }
    if(image.at&lt;uchar&gt;(width-1, i) == 255){ 
        floodFill(image,Point(i, width-1), 0);
    }
  } 

  //  -- Excluding objects that touch the first and last columns --
  for(int i=0; i&lt;width; i++){
    if(image.at&lt;uchar&gt;(i,0) == 255){ 
        floodFill(image,Point(0, i), 0);
    }
    if(image.at&lt;uchar&gt;(i,height-1) == 255){ 
        floodFill(image,Point(height-1, i), 0);
    }
  }

  //  -- Looking for objects and labeling them --
  nobjects=0; 
  for(int i=0; i&lt;height; i++){
    for(int j=0; j&lt;width; j++){
      if(image.at&lt;uchar&gt;(i,j) == 255){ 
        // Found an white object 
        nobjects++;
        p.x=j;
        p.y=i;
        floodFill(image,p,nobjects);
      }
    }
  }

 //  -- Changing background Color --
  floodFill(image,Point(0,0),255);

 //  -- Looking for bubbles with holes --
  holes = 0; counter = 1;
  for(int i=0; i&lt;height; i++){
    for(int j=0; j&lt;width; j++){
      if(image.at&lt;uchar&gt;(i,j) == 0 &amp;&amp; (int)image.at&lt;uchar&gt;(i,j-1)&gt;counter){ //se encontrar um buraco e já não tiver contado a bolha
        // Found a bubble with a hole 
        counter++;
        p.x=j-1;
        p.y=i;
        floodFill(image,p,counter);
      }
    }
  }

  std:: cout &lt;&lt; &quot;Number of bubbles: &quot; &lt;&lt;  nobjects &lt;&lt; &quot; and number of bubbles with holes: &quot; &lt;&lt; counter &lt;&lt;std::endl;

  imwrite(&quot;labeling.png&quot;, image);
  imshow(&quot;janela&quot;, image); 
  waitKey();
  return 0;
} 
</code></pre>
<p>As a result of the image processing, the output is:
<img src="../img/counting.png" alt="labeling" title="Labeling" /></p>
<a class="header" href="#exercise-4-equalizing-an-image" id="exercise-4-equalizing-an-image"><h1>Exercise 4. Equalizing an image</h1></a>
<p>An image histogram is a graphical representation of the intensity distribution of an image. It quantifies the number of pixels for each intensity value considered. <a href="https://docs.opencv.org/2.4/doc/tutorials/imgproc/histograms/histogram_equalization/histogram_equalization.html">OpenCV - Histogram equalization</a>
Histogram equalization is a method that improves the contrast in an image, in order to stretch out the intensity range. In this example, in equalize.cpp this outcome has been achived by using OpenCV function:equalize_hist:equalizeHist &lt;&gt;.</p>
<p><img src="../img/camera__.jpg" alt="original" title="Original" />
<img src="../img/equalized_image.jpg" alt="equalized" title="Equalized" /></p>
<p>This example was based on the <a href="https://agostinhobritojr.github.io/tutorial/pdi/exemplos/histogram.cpp">histogram.cpp</a> algorithm and answers to the proposed exercises at <a href="https://agostinhobritojr.github.io/tutorial/pdi/#_exerc%C3%ADcios_3">agostinhobritojr.github.io</a>.</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;opencv2/opencv.hpp&gt;

using namespace cv;
using namespace std;

/**  @function main */
int main( int argc, char** argv )
{
  Mat src, dst;

  string source_window = &quot;Source image&quot;;
  string equalized_window = &quot;Equalized Image&quot;;

  /// Camera 
  VideoCapture cap;

  //start camera
  cap.open(0);

  if(!cap.isOpened()){
    cout &lt;&lt; &quot;Camera not available&quot;;
    return -1;
  }

  while(1){
    /// capture image
    cap &gt;&gt; src;

    /// Convert to grayscale
    cvtColor( src, src, CV_BGR2GRAY );

    /// Apply Histogram Equalization
    equalizeHist( src, dst );

    /// Display results
    namedWindow( source_window, CV_WINDOW_NORMAL );
    namedWindow( equalized_window, CV_WINDOW_NORMAL );

    imshow( source_window, src );
    imshow( equalized_window, dst );

    if(waitKey(30) &gt;= 0) break;
    }

  // Closes all the windows
  destroyAllWindows();

  return 0;
}
</code></pre>
<a class="header" href="#what-does-this-program-do" id="what-does-this-program-do"><h3>What does this program do?</h3></a>
<pre><code>Create a VideoCapture object
Capture frame-by-frame
Convert the original image to grayscale
Equalize the Histogram by using the OpenCV function EqualizeHist
Display the source and equalized images in a window.
</code></pre>
<p>As we can see from the output image, the equalized image has a better distribution of the overall contrast, the furniture behind can be easily observed now. Original image is on the rigth and equalized on the left side
<img src="../img/equalization.png" alt="equalize" title="Labeling" /></p>
<a class="header" href="#exercise-5-motion-detection" id="exercise-5-motion-detection"><h1>Exercise 5. Motion Detection</h1></a>
<p>Analizing an image histogram, it is possible to observe several aspects of an image or a video, such as motion detection. In this example, we use the correlation between two frames of an video to determine if there was motion or not in it.</p>
<p>To achive this goal, the OpenCV <code>CalcHist</code> function was used to get the histogram of the frame, and the comparison between two frames was perfomed by the <code>compareHist</code> function, through the correlation comparison.;</p>
<a class="header" href="#what-does-this-program-do-1" id="what-does-this-program-do-1"><h3>What does this program do?</h3></a>
<pre><code>Create a VideoCapture object
Capture frame-by-frame
Calculate histogram by using the OpenCV function 
Display the source and equalized images in a window.
</code></pre>
<p>Calculates a histogram of a set of arrays:
<code>C++: void calcHist(const Mat* images, int nimages, const int* channels, InputArray mask, OutputArray hist, int dims, const int* histSize, const float** ranges, bool uniform=true, bool accumulate=false )</code>
OpenCV implements the function compareHist to perform a comparison. It also offers 4 different metrics to compute the matching, in this program we used the correlation as an metric.
<code>compareHist(histR, old_hist, CV_COMP_CORREL);</code></p>
<p>This example was based on the <a href="https://agostinhobritojr.github.io/tutorial/pdi/exemplos/histogram.cpp">histogram.cpp</a> algorithm and answers to the proposed exercises at <a href="https://agostinhobritojr.github.io/tutorial/pdi/#_exerc%C3%ADcios_3">agostinhobritojr.github.io</a>.</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;opencv2/opencv.hpp&gt;

using namespace cv;
using namespace std;

int main(int argc, char** argv){
  Mat image;
  int width, height;
  VideoCapture cap;
  vector&lt;Mat&gt; planes;
  Mat histR, motion, old_hist;
  int nbins = 64;
  float range[] = {0, 256};
  const float *histrange = { range };
  bool uniform = true;
  bool acummulate = false;

  // Start Camera
  cap.open(0);
  
  if(!cap.isOpened()){
    cout &lt;&lt; &quot;cameras indisponiveis&quot;;
    return -1;
  }
  
  // image size
  width  = cap.get(CV_CAP_PROP_FRAME_WIDTH);
  height = cap.get(CV_CAP_PROP_FRAME_HEIGHT);

  cout &lt;&lt; &quot;largura = &quot; &lt;&lt; width &lt;&lt; endl;
  cout &lt;&lt; &quot;altura  = &quot; &lt;&lt; height &lt;&lt; endl;

  // mat for histogram - analyzing only red here.
  int histw = nbins, histh = nbins/2;
  Mat histImgR(histh, histw, CV_8UC3, Scalar(0,0,0));

  // Motion alert
  motion = imread(&quot;img/motion_detected.png&quot;,CV_LOAD_IMAGE_COLOR);
  if(!motion.data)
    cout &lt;&lt; &quot;couldn't load image&quot; &lt;&lt; endl;

  namedWindow(&quot;window&quot;,WINDOW_AUTOSIZE);

  // faz uma vez para poder, calcular a primeira correlação, dar continuidade dentro do loop
  cap &gt;&gt; image;
  split (image, planes);
  calcHist(&amp;planes[0], 1, 0, Mat(), histR, 1,
             &amp;nbins, &amp;histrange,
             uniform, acummulate);
  normalize(histR, histR, 0, histImgR.rows, NORM_MINMAX, -1, Mat());
  
  histR.copyTo(old_hist);

  while(1){
    histR.copyTo(old_hist);
    cap &gt;&gt; image;
    split (image, planes);
    calcHist(&amp;planes[0], 1, 0, Mat(), histR, 1,
             &amp;nbins, &amp;histrange,
             uniform, acummulate);

    normalize(histR, histR, 0, histImgR.rows, NORM_MINMAX, -1, Mat());

    histImgR.setTo(Scalar(0));
    
    double compare = compareHist(histR, old_hist, CV_COMP_CORREL);
    cout &lt;&lt; compare &lt;&lt; endl;

    if ( compare &lt; 0.01)
    {
      cout &lt;&lt; &quot;Motion detected\n&quot;;
      motion.copyTo(image(Rect(0, histh, motion.size().width, motion.size().height)));
    }

    for(int i=0; i&lt;nbins; i++){
      line(histImgR,
           Point(i, histh),
           Point(i, histh-cvRound(histR.at&lt;float&gt;(i))),
           Scalar(0, 0, 255), 1, 8, 0);
    }
    histImgR.copyTo(image(Rect(0, 0       ,nbins, histh)));
    imshow(&quot;image&quot;, image);
    if(waitKey(30) &gt;= 0) break;
    old_hist.copyTo(histR);

  }
  return 0;
}
</code></pre>
<a class="header" href="#exercise-6-laplacian-of-a-gaussian-filter" id="exercise-6-laplacian-of-a-gaussian-filter"><h1>Exercise 6. Laplacian of a Gaussian filter</h1></a>
<p>This example was based on the <a href="https://agostinhobritojr.github.io/tutorial/pdi/exemplos/filtroespacial.cpp">filtroespacial.cpp</a> algorithm and answers to the proposed exercises at <a href="https://agostinhobritojr.github.io/tutorial/pdi/#_exerc%C3%ADcios_4">agostinhobritojr.github.io</a>.</p>
<p>This program adds one more function to the provided example. Through this new function, the laplacian of the gaussian of a captured image can be calculated by pressing the key &quot;z&quot; and the filtered image is displayed.</p>
<p>Comparing both laplacian and laplacion of gauss filters results, it is possible to conclude that the second filter returns a better filtering, as we can observe more easily the borders and cornes of the image.</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;opencv2/opencv.hpp&gt;

using namespace cv;
using namespace std;

void printmask(Mat &amp;m){
  for(int i=0; i&lt;m.size().height; i++){
    for(int j=0; j&lt;m.size().width; j++){
      cout &lt;&lt; m.at&lt;float&gt;(i,j) &lt;&lt; &quot;,&quot;;
    }
    cout &lt;&lt; endl;
  }
}

void menu(){
  cout &lt;&lt; &quot;\npressione a tecla para ativar o filtro: \n&quot;
    &quot;a - calcular modulo\n&quot;
    &quot;m - media\n&quot;
    &quot;g - gauss\n&quot;
    &quot;v - vertical\n&quot;
    &quot;h - horizontal\n&quot;
    &quot;l - laplaciano\n&quot;
    &quot;z - laplaciano do gaussiano\n&quot;
    &quot;esc - sair\n&quot;;
}

int main(int argvc, char** argv){
  VideoCapture video;
  float media[] = {1,1,1,
                   1,1,1,
                   1,1,1};
  float gauss[] = {1,2,1,
                   2,4,2,
                   1,2,1};
  float horizontal[]={-1,0,1,
                      -2,0,2,
                      -1,0,1};
  float vertical[]={-1,-2,-1,
                    0,0,0,
                    1,2,1};
  float laplacian[]={0,-1,0,
                     -1,4,-1,
                     0,-1,0};
  float lapgauss[]={0,0,1,0,0,
                    0,1,2,1,0,
                    1,2,-16,2,1,
                    0,1,2,1,0,
                    0,0,1,0,0};


  Mat cap, frame, frame32f, frameFiltered;
  Mat mask(3,3,CV_32F), mask1;
  Mat result, result1;
  double width, height, min, max;
  int absolut;
  char key;

  video.open(0);
  if(!video.isOpened())
    return -1;
  width=video.get(CV_CAP_PROP_FRAME_WIDTH);
  height=video.get(CV_CAP_PROP_FRAME_HEIGHT);
  std::cout &lt;&lt; &quot;largura=&quot; &lt;&lt; width &lt;&lt; &quot;\n&quot;;;
  std::cout &lt;&lt; &quot;altura =&quot; &lt;&lt; height&lt;&lt; &quot;\n&quot;;;

  namedWindow(&quot;filtroespacial&quot;,1);

  mask = Mat(3, 3, CV_32F, media);
  scaleAdd(mask, 1/9.0, Mat::zeros(3,3,CV_32F), mask1);
  swap(mask, mask1);
  absolut=1; // calcs abs of the image

  menu();
  for(;;){
    video &gt;&gt; cap;
    cvtColor(cap, frame, CV_BGR2GRAY);
    flip(frame, frame, 1);
    imshow(&quot;original&quot;, frame);
    frame.convertTo(frame32f, CV_32F);
    filter2D(frame32f, frameFiltered, frame32f.depth(), mask, Point(1,1), 0);
    if(absolut){
      frameFiltered=abs(frameFiltered);
    }
    frameFiltered.convertTo(result, CV_8U);
    imshow(&quot;filtroespacial&quot;, result);
    key = (char) waitKey(10);
    if( key == 27 ) break; // esc pressed!
    switch(key){
    case 'a':
      menu();
      absolut=!absolut;
      break;
    case 'm':
      menu();
      mask = Mat(3, 3, CV_32F, media);
      scaleAdd(mask, 1/9.0, Mat::zeros(3,3,CV_32F), mask1);
      mask = mask1;
      printmask(mask);
      break;
    case 'g':
      menu();
      mask = Mat(3, 3, CV_32F, gauss);
      scaleAdd(mask, 1/16.0, Mat::zeros(3,3,CV_32F), mask1);
      mask = mask1;
      printmask(mask);
      break;
    case 'h':
      menu();
      mask = Mat(3, 3, CV_32F, horizontal);
      printmask(mask);
      break;
    case 'v':
      menu();
      mask = Mat(3, 3, CV_32F, vertical);
      printmask(mask);
      break;
    case 'l':
      menu();
      mask = Mat(3, 3, CV_32F, laplacian);
      printmask(mask);
      break;
    case 'z':
      menu();
      mask = Mat(5, 5, CV_32F, lapgauss);
      printmask(mask);
    default:
      break;
    }
  }
  return 0;
}
</code></pre>
<a class="header" href="#exercise-7-tilty-shift" id="exercise-7-tilty-shift"><h1>Exercise 7. Tilty Shift</h1></a>
<p>This example was based on the <a href="https://agostinhobritojr.github.io/tutorial/pdi/exemplos/filtroespacial.cpp">addweighted.cpp</a> algorithm and answers to the proposed exercises at <a href="https://agostinhobritojr.github.io/tutorial/pdi/#_exerc%C3%ADcios_6">agostinhobritojr.github.io</a>.</p>
<p>This program adds three more functions to the provided example. Through these functions, the tiltyshift.cpp program makes the following adjustments:</p>
<ol>
<li>Adjust the height of the focus centre of the image</li>
<li>Adjust the decay of the blurred area</li>
<li>Adjust the vertical position of the focus centre area of the filtered image</li>
</ol>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;opencv2/opencv.hpp&gt;
#include &lt;cmath&gt;

using namespace cv;
using namespace std;

double alfa;


int center_slider=0;
int center_slider_max=100;

int alfa_slider = 0;
int alfa_slider_max = 100;
// height
int top_slider = 0;
int top_slider_max = 100;
Mat image1, image2, blended;
Mat imageTop;

char TrackbarName[50];

void on_trackbar_blend(int, void*){
 alfa = (double) alfa_slider/alfa_slider_max ;
 addWeighted( image2, alfa, imageTop, 1-alfa, 0.0, blended);
 imshow(&quot;addweighted&quot;, blended);
}

void on_trackbar_line(int, void*){
  image2.copyTo(imageTop);

  int width = image2.size().width;
  int height = image2.size().height;
  int limit = top_slider*height/100;
  int base = center_slider*height/100;


  if(limit &gt; 0){


    if(base &gt;= 0 &amp;&amp; base &lt;= height-limit){
      Mat tmp = image1(Rect(0, base, width,limit));
      tmp.copyTo(imageTop(Rect(0, base, width,limit)));
    }

    else{
      Mat tmp = image1(Rect(0, 0, width,limit));
      tmp.copyTo(imageTop(Rect(0, 0, width,limit)));
    }
  }

  on_trackbar_blend(alfa_slider,0);
}

int main(int argvc, char** argv){
  image1 = imread(&quot;img/sydney7.jpg&quot;);
  resize(image1,image1,Size(640,480));
  image1.copyTo(image2);
  namedWindow(&quot;addweighted&quot;, 1);
  image2.convertTo(image2,CV_32F);

  
  float media[]={1,1,1,
               1,1,1,
               1,1,1};
  Mat mascara;
  mascara = Mat(3,3,CV_32F,media);
  scaleAdd(mascara, 1/9.0, Mat::zeros(3,3,CV_32F), mascara);

  for (int i = 0; i &lt; 7; i++) {
        filter2D(image2, image2, image2.depth(), mascara, Point(1,1), 0);
  }
  image2.convertTo(image2, CV_8U);
  image2.copyTo(imageTop);
  sprintf( TrackbarName, &quot;Decay x %d&quot;, alfa_slider_max );
  createTrackbar( TrackbarName, &quot;addweighted&quot;,
          &amp;alfa_slider,
          alfa_slider_max,
          on_trackbar_blend );
  on_trackbar_blend(alfa_slider, 0 );

  sprintf( TrackbarName, &quot;Hight x %d&quot;, top_slider_max );
  createTrackbar( TrackbarName, &quot;addweighted&quot;,
          &amp;top_slider,
          top_slider_max,
          on_trackbar_line );
  on_trackbar_line(top_slider, 0 );

  sprintf( TrackbarName, &quot;Center x %d&quot;, top_slider_max );
  createTrackbar( TrackbarName, &quot;addweighted&quot;,
          &amp;center_slider,
          center_slider_max,
          on_trackbar_line );
  on_trackbar_line(center_slider, 0 );

  waitKey(0);
  imwrite(&quot;tiltyshift.jpg&quot;, blended);
  imshow(&quot;window&quot;,blended);
  imwrite(&quot;original.jpg&quot;, image1);
  imshow(&quot;window2&quot;,image1);
  return 0;
}
</code></pre>
<p>Original image
<img src="../img/original.jpg" alt="Original image" title="Original" /></p>
<p>Filtered image
<img src="../img/tiltyshift.jpg" alt="Filtered image" title="Filtered" /></p>
<a class="header" href="#unit-2" id="unit-2"><h1>Unit 2</h1></a>
<p>In this unit, the following examples were developed:</p>
<ul>
<li>Homomorphic filtering</li>
<li>Pointillism art</li>
<li>The K-means process</li>
</ul>
<a class="header" href="#exercise-1-homomorphic-filter" id="exercise-1-homomorphic-filter"><h1>Exercise 1. Homomorphic filter</h1></a>
<p>This example implements an homomorphic filter based on the <a href="https://agostinhobritojr.github.io/tutorial/pdi/exemplos/dft.cpp">dft.cpp</a> algorithm and answers to the proposed exercises at <a href="https://agostinhobritojr.github.io/tutorial/pdi/#_exerc%C3%ADcios_6">agostinhobritojr.github.io</a>.</p>
<p>The Homomorphic filter is based on the following function:</p>
<p><img src="../img/equation_homomorphic.png" alt="Equation" title="Equation" /></p>
<a class="header" href="#what-does-this-program-do-2" id="what-does-this-program-do-2"><h2>What does this program do?</h2></a>
<a class="header" href="#the-program-allows-4-different-adjustments-in-the-image" id="the-program-allows-4-different-adjustments-in-the-image"><h4>The program allows 4 different adjustments in the image</h4></a>
<ol>
<li>Regulate the low frequency component γLγL (referring to illumination);</li>
<li>Regulate the high frequency component γHγH (referring to reflectance);</li>
<li>Regulate the variable C, which controls the slope of the function as it transitions between γLγL and γHγH.</li>
<li>Adjust the variable D0D0;</li>
</ol>
<p>Original image
<img src="../img/original_homomorphic.png" alt="Original image" title="Original" /></p>
<p>Filtered image
<img src="../img/filtered_homomorphic.png" alt="Filtered image" title="Filtered" /></p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;opencv2/opencv.hpp&gt;
#include &lt;cmath&gt;

using namespace cv;
using namespace std;

Mat image, imageDft, padded;
char *filename;
float MAX = 100.0;
//-----------------VARIAVEIS DO FILTRO---------------------
float yl = 0, yh = 0, d0 = 0, c = 0;
float ylmax = 100, yhmax = 100, d0max = 256, cmax = 100;
int yl_slider = 0, yh_slider = 0, d0_slider = 0, c_slider = 0;
//---------------------------------------------------------

//valores ideais dos tamanhos da imagem para calculo da DFT
int dft_M, dft_N;
//---------------------------------------------------------

char TrackbarName[50];

void deslocaDFT(Mat&amp; image ){
    Mat tmp, A, B, C, D;

    // se a imagem tiver tamanho impar, recorta a regiao para
    // evitar cÃģpias de tamanho desigual
    image = image(Rect(0, 0, image.cols &amp; -2, image.rows &amp; -2));
    int cx = image.cols/2;
    int cy = image.rows/2;

    // reorganize quadrants
    // A B   -&gt;  D C
    // C D       B A
    A = image(Rect(0, 0, cx, cy));
    B = image(Rect(cx, 0, cx, cy));
    C = image(Rect(0, cy, cx, cy));
    D = image(Rect(cx, cy, cx, cy));

    // A &lt;-&gt; D
    A.copyTo(tmp);  D.copyTo(A);  tmp.copyTo(D);

    // C &lt;-&gt; B
    C.copyTo(tmp);  B.copyTo(C);  tmp.copyTo(B);
}

void filtroHM(){
  Mat filter = Mat(padded.size(), CV_32FC2, Scalar(0));
  Mat tmp = Mat(dft_M, dft_N, CV_32F);

  for (int i = 0; i &lt; dft_M; i++) {
      for (int j = 0; j &lt; dft_N; j++) {
          float d2 = pow(i - dft_M/2.0, 2) + pow(j - dft_N/2.0, 2);
          float exp = - c*(d2/pow(d0, 2));
          float filtroH = (yh - yl)*(1 - expf(exp) ) + yl;
          tmp.at&lt;float&gt; (i,j) = filtroH;
      }
  }

  Mat comps[] = {tmp, tmp};
  merge(comps, 2, filter);

  Mat dftClone = imageDft.clone();

  mulSpectrums(dftClone,filter,dftClone,0);

  deslocaDFT(dftClone);

  idft(dftClone, dftClone);

  vector&lt;Mat&gt; planos;

  split (dftClone, planos);

  normalize(planos[0], planos[0], 0, 1, CV_MINMAX);

  imshow(&quot;Filtro Homomorfico&quot;, planos[0]);
  imshow(&quot;Original&quot;, image);

}

void on_trackbar_yl(int, void*){
    yl = (float) yl_slider;
    yl = ylmax*yl/MAX;
    filtroHM();
}

void on_trackbar_d0(int, void*){
    d0 = d0_slider*d0max/MAX;
    filtroHM();
}

void on_trackbar_yh(int, void*) {
    yh = yh_slider*yhmax/MAX;
    filtroHM();
}
void on_trackbar_c(int, void*) {
    c = c_slider*cmax / MAX;
    filtroHM();
}


int main(int argvc , char** argv){
  //open image
      if (argvc != 2) {
        cerr &lt;&lt; &quot;Usage: &quot; &lt;&lt; argv[0] &lt;&lt; &quot; &lt;img_path&gt;&quot; &lt;&lt; endl;
        return 1;
    }

    filename = argv[1];
    image = imread(filename);
  cvtColor(image, image, CV_BGR2GRAY);
  // Identify the optimum size for 
  // Calculating FFT
  dft_M = getOptimalDFTSize(image.rows);
  dft_N = getOptimalDFTSize(image.cols);



  // Image padding
  Mat_&lt;float&gt; zeros;
  copyMakeBorder(image, padded, 0,
                 dft_M - image.rows, 0,
                 dft_N - image.cols,
                 BORDER_CONSTANT, Scalar::all(0));

  // Zero padding - complex part of the matrix
  zeros = Mat_&lt;float&gt;::zeros(padded.size());

  // prepare the complex part 
  imageDft = Mat(padded.size(), CV_32FC2, Scalar(0));

  copyMakeBorder(image, padded, 0,
                 dft_M - image.rows, 0,
                 dft_N - image.cols,
                 BORDER_CONSTANT, Scalar::all(0));

  Mat_&lt;float&gt; realInput = Mat_&lt;float&gt;(padded);

  // insere the two components within the matrices arrays
  vector&lt;Mat&gt; planos;
  planos.push_back(realInput);
  planos.push_back(zeros);

  // combine matrices array into a single
  // complex component
  merge(planos, imageDft);

  // calcula o dft
  dft(imageDft, imageDft);
  deslocaDFT(imageDft);

  namedWindow(&quot;Homomorfic filter&quot;, WINDOW_NORMAL);

  sprintf( TrackbarName, &quot;Yh&quot;);
  createTrackbar( TrackbarName, &quot;Filtro Homomorfico&quot;,
                  &amp;yh_slider,
                  MAX,
                  on_trackbar_yh);

  sprintf( TrackbarName, &quot;YL&quot;);
  createTrackbar( TrackbarName, &quot;Filtro Homomorfico&quot;,
                  &amp;yl_slider,
                  MAX,
                  on_trackbar_yl);

  sprintf( TrackbarName, &quot;D0&quot;);
  createTrackbar( TrackbarName, &quot;Filtro Homomorfico&quot;,
                  &amp;d0_slider,
                  MAX,
                  on_trackbar_d0 );
  sprintf(TrackbarName, &quot;C&quot;);
  createTrackbar( TrackbarName, &quot;Filtro Homomorfico&quot;,
                  &amp;c_slider,
                  MAX,
                  on_trackbar_c);
  filtroHM();
  waitKey(0);

  return 0;
}
 
</code></pre>
<p>git</p>
<a class="header" href="#exercise-2-pointillism-art" id="exercise-2-pointillism-art"><h1>Exercise 2. Pointillism art</h1></a>
<p>This section uses Canny Edge Detection, developed by John F. Canny in 1986, to create pointillism arts.
To achieve this goal, we can simulate a painting by drawing circles that work out as a pointillism art. The example below perform the desired effect of pointillism through image processing.</p>
<p>The following steps were used to accomplish this effect:</p>
<a class="header" href="#what-does-this-program-do-3" id="what-does-this-program-do-3"><h2>What does this program do?</h2></a>
<a class="header" href="#the-program-allows-4-different-adjustments-in-the-image-1" id="the-program-allows-4-different-adjustments-in-the-image-1"><h4>The program allows 4 different adjustments in the image</h4></a>
<ol>
<li>Apply canny algorithm on an image.</li>
<li>Use the edges identified by the canny algorithm to draw smaller circles on them;</li>
<li>Uses the Canny threshold to increase the quality of the painting affect.</li>
</ol>
<p>This example was based on the <a href="https://agostinhobritojr.github.io/tutorial/pdi/exemplos/pontilhismo.cpp">pointilhismo.cpp</a> and <a href="https://agostinhobritojr.github.io/tutorial/pdi/exemplos/canny.cpp">canny.cpp</a> algorithms and it answers to the proposed exercises at [agostinhobritojr.github.io]https://agostinhobritojr.github.io/tutorial/pdi/#_exerc%C3%ADcios_7).</p>
<p>Original image
<img src="../img/sydney-pointillism2.jpg" alt="Original image" title="Original" /></p>
<p>Canny edge detector
<img src="../img/sydney-canny.png" alt="Canny-edge detector" title="Canny edge detector" /></p>
<p>Filtered image
<img src="../img/sydney-point.png" alt="Filtered image" title="Filtered" /></p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &quot;opencv2/opencv.hpp&quot;
#include &lt;fstream&gt;
#include &lt;iomanip&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;numeric&gt;
#include &lt;ctime&gt;
#include &lt;cstdlib&gt;

using namespace std;
using namespace cv;


#define STEP 4
#define JITTER 2
#define RAIO 5

int top_slider = 10;
int top_slider_max = 200;

char TrackbarName[50];

Mat image,imgray, border,points;
  int width, height;
  Vec3b colors;
  int x, y;
  vector&lt;int&gt; yrange;
  vector&lt;int&gt; xrange;

void on_trackbar_canny(int, void*){

  Canny(imgray, border, top_slider, 3*top_slider);
  imshow(&quot;cannyborders.png&quot;, border);
  points = Mat(height, width, CV_8UC3, Scalar(255,255,255));
  std::random_shuffle(xrange.begin(), xrange.end());
  for(auto i : xrange){
    random_shuffle(yrange.begin(), yrange.end());
    for(auto j : yrange){

      if(border.at&lt;uchar&gt;(j,i) == 255)
      {
          x = i+rand()%(2*JITTER)-JITTER+1;
          y = j+rand()%(2*JITTER)-JITTER+1;
          colors = image.at&lt;Vec3b&gt;(y,x);
          circle(points, Point(x,y),2, CV_RGB(colors[2],colors[1],colors[0]), -1, CV_AA);
      }
      else{
          x = i+rand()%(2*JITTER)-JITTER+1;
          y = j+rand()%(2*JITTER)-JITTER+1;
          colors = image.at&lt;Vec3b&gt;(x,y);
          circle(points,
                 cv::Point(y,x),
                 RAIO,
                 CV_RGB(colors[2],colors[1],colors[0]),
                 -1,
                 CV_AA);
      }
    }
  }
  imshow(&quot;canny&quot;,points);

}

int main(int argc, char**argv){

  image= imread(argv[1],CV_LOAD_IMAGE_COLOR);
  cvtColor(image,imgray, CV_BGR2GRAY);

  srand(time(0));

  if(!image.data){
  cout &lt;&lt; &quot;nao abriu&quot; &lt;&lt; argv[1] &lt;&lt; endl;
    cout &lt;&lt; argv[0] &lt;&lt; &quot; imagem.jpg&quot;;
    exit(0);
  }

  width=image.size().width;
  height=image.size().height;

  xrange.resize(height/STEP);
  yrange.resize(width/STEP);

  iota(xrange.begin(), xrange.end(), 0);
  iota(yrange.begin(), yrange.end(), 0);

  for(uint i=0; i&lt;xrange.size(); i++){
    xrange[i]= xrange[i]*STEP+STEP/2;
  }

  for(uint i=0; i&lt;yrange.size(); i++){
    yrange[i]= yrange[i]*STEP+STEP/2;
  }

  sprintf( TrackbarName, &quot;Threshold_inferior&quot;, top_slider_max );

  namedWindow(&quot;canny&quot;,1);
  createTrackbar( TrackbarName, &quot;canny&quot;,
                &amp;top_slider,
                top_slider_max,
                on_trackbar_canny );

  on_trackbar_canny(top_slider, 0 );

  waitKey();
  imwrite(&quot;cannypontos.png&quot;,points);
  return 0;
}

</code></pre>
<a class="header" href="#exercise-3-k-means-proccess" id="exercise-3-k-means-proccess"><h1>Exercise 3. K-means proccess</h1></a>
<p>This example was based on the <a href="https://agostinhobritojr.github.io/tutorial/pdi/exemplos/kmeans.cpp">kmeans.cpp</a> algorithm and answers to the proposed exercises at [agostinhobritojr.github.io]https://agostinhobritojr.github.io/tutorial/pdi/#_exerc%C3%ADcios_8).</p>
<p>The following steps were used to accomplish this effect:</p>
<a class="header" href="#what-does-this-program-do-4" id="what-does-this-program-do-4"><h2>What does this program do?</h2></a>
<a class="header" href="#the-k-means-algorithm-works-according-to-the-following-steps" id="the-k-means-algorithm-works-according-to-the-following-steps"><h4>The k-means algorithm works according to the following steps:</h4></a>
<ol>
<li>Choose k as the number of classes for the vectors xi of N samples, i = 1,2, ⋯, N.</li>
<li>Choose m1, m2, ⋯, mk as initial approximations for the class centers.</li>
<li>Sort each sample xi using, for example, a minimum distance classifier (Euclidean distance).</li>
<li>Recalculate the averages mj using the result of the previous step.</li>
<li>If the new averages are consistent (do not change considerably), finalize the algorithm. If not, recalculate the centers and redo the classification.</li>
</ol>
<pre><code class="language-cpp">#include &lt;opencv2/opencv.hpp&gt;
#include &lt;cstdlib&gt;
#include &lt;ctime&gt;

using namespace cv;

int main( int argc, char** argv ){
  for(int i = 0; i &lt; 10; i++){

    int nClusters = 20;
    Mat labels;
    int nRounds = 1;
    Mat centers;
    char name[30];

    if(argc!=3){
    exit(0);
    }

    Mat img = imread( argv[1], CV_LOAD_IMAGE_COLOR);
    Mat samples(img.rows * img.cols, 3, CV_32F);

    for( int y = 0; y &lt; img.rows; y++ ){
      for( int x = 0; x &lt; img.cols; x++ ){
        for( int z = 0; z &lt; 3; z++){
          samples.at&lt;float&gt;(y + x*img.rows, z) = img.at&lt;Vec3b&gt;(y,x)[z];
      }
    }
    }

    kmeans(samples,
       nClusters,
       labels,
       TermCriteria(CV_TERMCRIT_ITER|CV_TERMCRIT_EPS, 10000, 0.0001),
       nRounds,
       KMEANS_RANDOM_CENTERS,
       centers );


    Mat labeled( img.size(), img.type() );
    for( int y = 0; y &lt; img.rows; y++ ){
      for( int x = 0; x &lt; img.cols; x++ ){
      int indice = labels.at&lt;int&gt;(y + x*img.rows,0);
      labeled.at&lt;Vec3b&gt;(y,x)[0] = (uchar) centers.at&lt;float&gt;(indice, 0);
      labeled.at&lt;Vec3b&gt;(y,x)[1] = (uchar) centers.at&lt;float&gt;(indice, 1);
      labeled.at&lt;Vec3b&gt;(y,x)[2] = (uchar) centers.at&lt;float&gt;(indice, 2);
    }
    }
    sprintf(name,  &quot;test%d.jpg&quot;, i);
    imwrite(name, labeled);
    //waitKey( 0 );
  }
}
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        
        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://localhost:3001");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload(true); // force reload from server (not from cache)
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
